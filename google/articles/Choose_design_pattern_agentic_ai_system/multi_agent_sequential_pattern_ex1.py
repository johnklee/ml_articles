#!/usr/bin/env python
"""Here we will implement a simplified code development pipeline.

This pipeline includes:
- Code Writer Agent: An LLM Agent that generates initial code based on a
  specification or request.
- Code Reviewer Agent: An LLM Agent that reviews the generated code for errors,
  style issues, and adherence to best practices. It receives the output of the
  `Code Writer Agent`.
- Code Refactorer Agent: An LLM Agent that takes the reviewed code (and the
  reviewer's comments) and refactors it to improve quality and address issues.
"""
import asyncio
import json # Needed for pretty printing dicts
from typing import Any

from google.adk.agents import SequentialAgent, LlmAgent
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
from google.genai import types
from pydantic import BaseModel, Field

# --- 0. Define Constants and output format---
APP_NAME = "code_development_pipeline_app"
USER_ID = "test_user_123"
SESSION_TEST_ID = "session_test"
MODEL_NAME = "gemini-2.0-flash"
FINAL_OUTPUT_KEY = "final_generated_code"

# Output schema ONLY for the second agent
class GeneratedCodeOutput(BaseModel):
  request: str = Field(description="Refined request to generate the code.")
  generated_code: str = Field(
      description=((
          "The generated Python code without prefix '```python' and post fix '```'. "
          "Only keep the Python code here."
      )))


# --- 1. Define Sub-Agents for Each Pipeline Stage ---
# Code Writer Agent
# Takes the initial specification (from user query) and writes code.
code_writer_agent = LlmAgent(
    name="CodeWriterAgent",
    model=MODEL_NAME,
    # Change 3: Improved instruction
    instruction="""You are a Python Code Generator.
Based *only* on the user's request, write Python code that fulfills the requirement.
Output *only* the complete Python code block, enclosed in triple backticks (```python ... ```).
Do not add any other text before or after the code block.
""",
    description="Writes initial Python code based on a specification.",
    output_key="generated_code",  # Stores output in state['generated_code']
)

# Code Reviewer Agent
# Takes the code generated by the previous agent (read from state) and provides feedback.
code_reviewer_agent = LlmAgent(
    name="CodeReviewerAgent",
    model=MODEL_NAME,
    # Change 3: Improved instruction, correctly using state key injection
    instruction="""You are an expert Python Code Reviewer.
    Your task is to provide constructive feedback on the provided code.

    **Code to Review:**
    ```python
    {generated_code}
    ```

**Review Criteria:**
1.  **Correctness:** Does the code work as intended? Are there logic errors?
2.  **Readability:** Is the code clear and easy to understand? Follows PEP 8 style guidelines?
3.  **Efficiency:** Is the code reasonably efficient? Any obvious performance bottlenecks?
4.  **Edge Cases:** Does the code handle potential edge cases or invalid inputs gracefully?
5.  **Best Practices:** Does the code follow common Python best practices?

**Output:**
Provide your feedback as a concise, bulleted list. Focus on the most important points for improvement.
If the code is excellent and requires no changes, simply state: "No major issues found."
Output *only* the review comments or the "No major issues" statement.
""",
    description="Reviews code and provides feedback.",
    output_key="review_comments", # Stores output in state['review_comments']
)

# Code Refactorer Agent
# Takes the original code and the review comments (read from state) and refactors the code.
code_refactorer_agent = LlmAgent(
    name="CodeRefactorerAgent",
    model=MODEL_NAME,
    # Change 3: Improved instruction, correctly using state key injection
    instruction="""You are a Python Code Refactoring AI.
Your goal is to improve the given Python code based on the provided review comments.

  **Original Code:**
  ```python
  {generated_code}
  ```

  **Review Comments:**
  {review_comments}

**Task:**
Carefully apply the suggestions from the review comments to refactor the original code.
If the review comments state "No major issues found," return the original code unchanged.
Ensure the final code is complete, functional, and includes necessary imports and docstrings.

**Output:**
Output *only* the final, refactored Python code block, enclosed in triple backticks (```python ... ```).
Do not add any other text before or after the code block.
""",
    description="Refactors code based on review comments.",
    output_key=FINAL_OUTPUT_KEY, # Stores output in state['refactored_code']
    output_schema=GeneratedCodeOutput,
)

# --- 2. Create the SequentialAgent ---
# This agent orchestrates the pipeline by running the sub_agents in order.
code_pipeline_agent = SequentialAgent(
    name="CodePipelineAgent",
    sub_agents=[code_writer_agent, code_reviewer_agent, code_refactorer_agent],
    description="Executes a sequence of code writing, reviewing, and refactoring.",
    # The agents will run in the order provided: Writer -> Reviewer -> Refactorer
)

# For ADK tools compatibility, the root agent must be named `root_agent`
root_agent = code_pipeline_agent


# --- 3. Build runner and session ---
async def create_runners():
  # --- 5. Set up Session Management and Runners ---
  session_service = InMemorySessionService()
  print(f'session_service: {session_service.__class__}')

  # Create separate sessions for clarity, though not strictly necessary if context is managed
  #asyncio.run(session_service.create_session(
  #    app_name=APP_NAME,
  #    user_id=USER_ID,
  #    session_id=SESSION_TEST_ID))

  session = await session_service.create_session(
    app_name=APP_NAME,
    user_id=USER_ID,
    session_id=SESSION_TEST_ID)

  # Create a runner for EACH agent
  runner = Runner(
      agent=root_agent,
      app_name=APP_NAME,
      session_service=session_service
  )
  return runner, session_service, session


# --- 4. Call the agent.
async def call_agent_and_print(
    text: str,
    runner_instance: Runner,
    session_service: Any,
    agent_instance: LlmAgent = root_agent,
    session_id: str = SESSION_TEST_ID,
):
  """Sends a query to the specified agent/runner and prints results."""
  print(f"\n>>> Calling Agent: '{agent_instance.name}' | Query: {text}")

  user_content = types.Content(
      role='user', parts=[types.Part(text=text)])

  final_response_content = '?'

  async for event in runner_instance.run_async(
      user_id=USER_ID,
      session_id=session_id,
      new_message=user_content):
    # print(f"Event: {event.type}, Author: {event.author}") # Uncomment for detailed logging
    if event.is_final_response() and event.content and event.content.parts:
      # For output_schema, the content is the JSON string itself
      final_response_content = event.content.parts[0].text

  current_session = await session_service.get_session(
      app_name=APP_NAME,
      user_id=USER_ID,
      session_id=session_id)

  stored_output = current_session.state.get(FINAL_OUTPUT_KEY)

  # Pretty print if the stored output looks like JSON (likely from output_schema)
  print(stored_output['generated_code'])
  print("-" * 30)


# --- 5. Run Interactions ---
async def main():
  runner, session_service, session = await create_runners()
  print("--- Testing Agent  ---")
  await call_agent_and_print(
      (
          "Generate code to print Pascal Triangle with argument `n` to decide the hight of it! "
          "e.g: `n=1` will print `1`; `n=2` will print `1\n1  1` etc"
      ),
      runner,
      session_service)


if __name__ == "__main__":
  asyncio.run(main())
